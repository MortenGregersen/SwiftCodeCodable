//
//  SwiftWriter.swift
//  InterfaceCoderCore
//
//  Created by Morten Bjerg Gregersen on 17/10/2018.
//  Copyright Â© 2018 MoGee. All rights reserved.
//

import Foundation

public class SwiftWriter {

	public static func generateHeaderAndImports() -> String {
		return """
//
// Generated by InterfaceCoder.
//

import UIKit
\n
"""
	}

	public static func generateClassDeclaration(name: String, parent: String? = nil, content: String) -> String {
		let nameAndParent: String
		if let parent = parent {
			nameAndParent = "\(name): \(parent)"
		} else {
			nameAndParent = name
		}
		var classDeclaration = "class \(nameAndParent) {\n"
		if content.lengthOfBytes(using: .utf8) > 0 {
			classDeclaration += "\n\(content.indented())"
		}
		classDeclaration += "\n}"
		return classDeclaration
	}

	public static func generateFunctionDeclaration(type: FunctionType, arguments: [String: String]? = nil,
												   returnType: String? = nil, content: String) -> String {
		let argumentsList = arguments?.map { "\($0): \($1)" }.joined(separator: ", ") ?? ""
		var declaration = "\(type.stringValue)(\(argumentsList))"
		if let returnType = returnType {
			declaration += " -> \(returnType)"
		}
		declaration += " {"
		declaration += "\n" + content.indented()
		declaration += "\n}"
		return declaration
	}

	public static func generateVariableAssignment(type: VarAssingmentType, destination: String, value: String) -> String {
		return "\(type.rawValue) \(destination) = \(value)"
	}
}

extension SwiftWriter {

	public enum VarAssingmentType: String {
		case `let`
		case `var`
	}

	public enum FunctionType {
		case plain(name: String)
		case `class`(name: String)
		case initializer(required: Bool, override: Bool, canReturnNil: Bool)

		internal var stringValue: String {
			switch self {
			case .plain(let name):
				return "func \(name)"
			case .class(let name):
				return "class func \(name)"
			case .initializer(let required, let override, let canReturnNil):
				var initializer = "init"
				if override {
					initializer = "override \(initializer)"
				}
				if required {
					initializer = "required \(initializer)"
				}
				if canReturnNil {
					initializer += "?"
				}
				return initializer
			}
		}
	}
}

public enum Indentation {
	case spaceTabs(Int)
	case tabs(Int)

	public var stringValue: String {
		switch self {
		case .spaceTabs(let spaceTabs):
			return String(repeating: "    ", count: spaceTabs)
		case .tabs(let tabs):
			return String(repeating: "\t", count: tabs)
		}
	}

	var increased: Indentation {
		switch self {
		case .spaceTabs(let spaceTabs):
			return Indentation.spaceTabs(spaceTabs + 1)
		case .tabs(let tabs):
			return Indentation.tabs(tabs + 1)
		}
	}

	var decreased: Indentation {
		switch self {
		case .spaceTabs(let spaceTabs):
			return Indentation.spaceTabs(spaceTabs - 1)
		case .tabs(let tabs):
			return Indentation.tabs(tabs - 1)
		}
	}
}

extension String {

	func indented(with indentation: Indentation = .tabs(1)) -> String {
		return self.components(separatedBy: "\n").map({ "\(indentation.stringValue)\($0)" }).joined(separator: "\n")
	}
}
