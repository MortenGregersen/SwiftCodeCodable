//
//  SwiftWriter.swift
//  SwiftCodeCodable
//
//  Created by Morten Bjerg Gregersen on 17/10/2018.
//

import Foundation
import SwiftSyntax

public class SwiftWriter {

	public static func generateHeaderAndImports() -> String {
		let comment = """
//
// Generated by SwiftCodeCodable.
//


"""
		let importDeclSyntax = ImportDeclSyntax { builder in
			builder.useImportTok(SyntaxFactory.makeImportKeyword(leadingTrivia: .garbageText(comment)))
			builder.addAccessPathComponent(AccessPathComponentSyntax({ pathComponentBuilder in
				pathComponentBuilder.useName(SyntaxFactory.makeIdentifier("UIKit",
																		  leadingTrivia: .spaces(1),
																		  trailingTrivia: .newlines(2)))
			}))
		}
		return importDeclSyntax.description
	}

	public static func generateClassDeclaration(name: String, parent: String? = nil, content: String) -> String {
		let classDeclSyntax = ClassDeclSyntax { builder in
			builder.useClassKeyword(SyntaxFactory.makeClassKeyword(trailingTrivia: .spaces(1)))
			builder.useIdentifier(SyntaxFactory.makeIdentifier(name))
			if let parent = parent {
				let colon = SyntaxFactory.makeColonToken(trailingTrivia: .spaces(1))
				let inheritedType = SyntaxFactory.makeInheritedType(typeName: SyntaxFactory.makeSimpleTypeIdentifier(name: SyntaxFactory.makeIdentifier(parent), genericArgumentClause: nil), trailingComma: nil)
				let inheritedTypeCollection = SyntaxFactory.makeInheritedTypeList([inheritedType])
				let inheritanceClause = SyntaxFactory.makeTypeInheritanceClause(colon: colon,
																				inheritedTypeCollection: inheritedTypeCollection)
				builder.useInheritanceClause(inheritanceClause)
			}
			builder.useMembers(MemberDeclBlockSyntax { memberBuilder in
				var garbageText: Trivia = []
				if content.lengthOfBytes(using: .utf8) > 0 {
					garbageText = .garbageText("\n\n\(content.indented())")
				}
				memberBuilder.useLeftBrace(SyntaxFactory.makeLeftBraceToken(leadingTrivia: .spaces(1),
																			trailingTrivia: garbageText))
				memberBuilder.useRightBrace(SyntaxFactory.makeRightBraceToken(leadingTrivia: .newlines(1)))
			})
		}
		return classDeclSyntax.description
	}

	public static func generateFunctionDeclaration(type: FunctionType, arguments: [String: String]? = nil,
												   returnType: String? = nil, content: String) -> String {
		if case let .initializer(required, override, canReturnNil) = type {
			return InitializerDeclSyntax { builder in
				if required {
					builder.addModifier(DeclModifierSyntax { modifierBuilder in
						modifierBuilder.useName(SyntaxFactory.makeIdentifier("required", trailingTrivia: .spaces(1)))
					})
				}
				if override {
					builder.addModifier(DeclModifierSyntax { modifierBuilder in
						modifierBuilder.useName(SyntaxFactory.makeIdentifier("override", trailingTrivia: .spaces(1)))
					})
				}
				builder.useInitKeyword(SyntaxFactory.makeInitKeyword())
				if canReturnNil {
					builder.useOptionalMark(SyntaxFactory.makePostfixQuestionMarkToken())
				}
				builder.useParameters(functionParameters(arguments: arguments))
				builder.useBody(functionBody(content: content))
			}.description
		}
		let funcDeclSyntax = FunctionDeclSyntax { builder in
			builder.useFuncKeyword(SyntaxFactory.makeFuncKeyword(trailingTrivia: .spaces(1)))
			if case let .plain(name) = type {
				builder.useIdentifier(SyntaxFactory.makeIdentifier(name))
			} else if case let .class(name) = type {
				builder.addModifier(DeclModifierSyntax { modifierBuilder in
					modifierBuilder.useName(SyntaxFactory.makeClassKeyword(trailingTrivia: .spaces(1)))
				})
				builder.useIdentifier(SyntaxFactory.makeIdentifier(name))
			}
			builder.useSignature(functionSignature(arguments: arguments, returnType: returnType))
			builder.useBody(functionBody(content: content))
		}
		return funcDeclSyntax.description
	}
	
	private static func functionSignature(arguments: [String: String]?, returnType: String?) -> FunctionSignatureSyntax {
		return FunctionSignatureSyntax { signatureBuilder in
			signatureBuilder.useInput(functionParameters(arguments: arguments))
			if let returnType = returnType {
				signatureBuilder.useOutput(ReturnClauseSyntax { returnClauseBuilder in
					returnClauseBuilder.useArrow(SyntaxFactory.makeArrowToken(leadingTrivia: .spaces(1),
																			  trailingTrivia: .spaces(1)))
					returnClauseBuilder.useReturnType(SyntaxFactory.makeTypeIdentifier(returnType))
				})
			}
		}
	}
	
	private static func functionParameters(arguments: [String: String]?) -> ParameterClauseSyntax {
		return ParameterClauseSyntax { parameterClauseBuilder in
			parameterClauseBuilder.useLeftParen(SyntaxFactory.makeLeftParenToken())
			parameterClauseBuilder.useRightParen(SyntaxFactory.makeRightParenToken())
			arguments?.forEach({ (parameterName, parameterType) in
				parameterClauseBuilder.addFunctionParameter(FunctionParameterSyntax { parameterBuilder in
					parameterBuilder.useFirstName(SyntaxFactory.makeIdentifier(parameterName))
					parameterBuilder.useColon(SyntaxFactory.makeColonToken(trailingTrivia: .spaces(1)))
					parameterBuilder.useType(SyntaxFactory.makeTypeIdentifier(parameterType))
				})
			})
		}
	}
	
	private static func functionBody(content: String) -> CodeBlockSyntax {
		return CodeBlockSyntax { codeBlockBuilder in
			var garbageText: Trivia = []
			if content.lengthOfBytes(using: .utf8) > 0 {
				garbageText = .garbageText("\n\(content.indented())")
			}
			codeBlockBuilder.useLeftBrace(SyntaxFactory.makeLeftBraceToken(leadingTrivia: .spaces(1),
																		   trailingTrivia: garbageText))
			codeBlockBuilder.useRightBrace(SyntaxFactory.makeRightBraceToken(leadingTrivia: .newlines(1)))
		}
	}

	public static func generateVariableAssignment(type: VarAssingmentType, destination: String, value: String) -> String {
		return "\(type.rawValue) \(destination) = \(value)"
	}
}

extension SwiftWriter {

	public enum VarAssingmentType: String {
		case `let`
		case `var`
	}

	public enum FunctionType {
		case plain(name: String)
		case `class`(name: String)
		case initializer(required: Bool, override: Bool, canReturnNil: Bool)
	}
}

public enum Indentation {
	case spaceTabs(Int)
	case tabs(Int)

	public var stringValue: String {
		switch self {
		case .spaceTabs(let spaceTabs):
			return String(repeating: "    ", count: spaceTabs)
		case .tabs(let tabs):
			return String(repeating: "\t", count: tabs)
		}
	}

	var increased: Indentation {
		switch self {
		case .spaceTabs(let spaceTabs):
			return Indentation.spaceTabs(spaceTabs + 1)
		case .tabs(let tabs):
			return Indentation.tabs(tabs + 1)
		}
	}

	var decreased: Indentation {
		switch self {
		case .spaceTabs(let spaceTabs):
			return Indentation.spaceTabs(spaceTabs - 1)
		case .tabs(let tabs):
			return Indentation.tabs(tabs - 1)
		}
	}
}

extension String {

	func indented(with indentation: Indentation = .tabs(1)) -> String {
		return self.components(separatedBy: "\n").map({ "\(indentation.stringValue)\($0)" }).joined(separator: "\n")
	}
}
